% ----------------------- TODO ---------------------------
%Template 
\documentclass[a4paper]{scrartcl}
\usepackage[utf8]{inputenc}
%\usepackage[ngerman]{babel}
\usepackage{geometry,forloop,fancyhdr,fancybox,lastpage}
\usepackage{listings}
\lstset{frame=tb,
	language=Java,
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false,
	columns=flexible,
	basicstyle={\small\ttfamily},
	numbers=left,
	numberstyle=\tiny\color{gray},
	keywordstyle=\color{blue},
	commentstyle=\color{dkgreen},
	stringstyle=\color{mauve},
	breaklines=true,
	breakatwhitespace=true,
	tabsize=3
}
\geometry{a4paper,left=3cm, right=3cm, top=3cm, bottom=3cm}
% Diese Daten müssen pro Blatt angepasst werden:
\newcommand{\NUMBER}{4}
\usepackage{graphicx}
\graphicspath{{/home/stefan/projects/m_alg/}}
\newcommand{\EXERCISES}{5}
% Diese Daten müssen einmalig pro Vorlesung angepasst werden:
\newcommand{\COURSE}{Methoden der Algorithmik}
%\newcommand{\TUTOR}{Benjamin Coban}
\newcommand{\STUDENTA}{Stefan Wezel}
\newcommand{\STUDENTB}{Lukas Günthner}
%\newcommand{\STUDENTC}{Gwent Krause}
\newcommand{\DEADLINE}{\date}
% ----------------------- TODO ---------------------------

%Math
\usepackage{amsmath,amssymb,tabularx}

%Figures
\usepackage{graphicx,tikz,color,float}
\graphicspath{ {home/stefan/picures/} }
\usetikzlibrary{shapes,trees}

%Algorithms
\usepackage[ruled,linesnumbered]{algorithm2e}

%Kopf- und Fußzeile
\pagestyle {fancy}
%\fancyhead[L]{Tutor: \TUTOR}
\fancyhead[C]{\COURSE}
\fancyhead[R]{\today}

\fancyfoot[L]{}
\fancyfoot[C]{}
\fancyfoot[R]{Seite \thepage}

%Formatierung der Überschrift, hier nichts ändern
\def\header#1#2{
	\begin{center}
		{\Large\bf Übungsblatt #1}\\
		{(Abgabetermin #2)}
	\end{center}
}

%Definition der Punktetabelle, hier nichts ändern
\newcounter{punktelistectr}
\newcounter{punkte}
\newcommand{\punkteliste}[2]{%
	\setcounter{punkte}{#2}%
	\addtocounter{punkte}{-#1}%
	\stepcounter{punkte}%<-- also punkte = m-n+1 = Anzahl Spalten[1]
	\begin{center}%
		\begin{tabularx}{\linewidth}[]{@{}*{\thepunkte}{>{\centering\arraybackslash} X|}@{}>{\centering\arraybackslash}X}
			\forloop{punktelistectr}{#1}{\value{punktelistectr} < #2 } %
			{%
				\thepunktelistectr &
			}
			#2 &  $\Sigma$ \\
			\hline
			\forloop{punktelistectr}{#1}{\value{punktelistectr} < #2 } %
			{%
				&
			} &\\
			\forloop{punktelistectr}{#1}{\value{punktelistectr} < #2 } %
			{%
				&
			} &\\
		\end{tabularx}
	\end{center}
}

\begin{document}
	
	\begin{tabularx}{\linewidth}{m{0.2 \linewidth}X}
		\begin{minipage}{\linewidth}
			\STUDENTA\\
			\STUDENTB\\
			%\STUDENTC
		\end{minipage} & \begin{minipage}{\linewidth}
			\punkteliste{1}{\EXERCISES}
		\end{minipage}\\
	\end{tabularx}
	
	%\header{Nr. \NUMBER}{\DEADLINE}
	
	% ----------------------- TODO ---------------------------
	% Hier werden die Aufgaben/Lösungen eingetragen



\section*{Aufgabe 1}
\subsection*{(a)}
Die erste For-Loop färbt zunächst alle Knoten. Jeder Knoten wird dafür zuerst blau eingefärbt, um dannach mit einer bestimmten Wahrscheinlichkeit blau gefärbt zu werden.\\
Anschließend erneut jeder Knoten in einer zweiten For-Loop betrachtet und überprüft ob dieser rot ist oder alle seine Nachbarn blau sind. Ist einer dieser Fälle wahr, so wird er der Menge $S$ hinzugefügt, bei welcher es sich um eine dominierende Menge handelt.\\
Die Menge ist eine dominierende, da durch hinzufügen von Knoten, deren Nachbarn alle Blau sind sichergestellt wird, dass für alle benachbarte Knoten nun ein anliegender Knoten in die Menge $S$ aufgenommen wurde.\\
Wären alle Knoten blau, so würden mit diesem Algorithmus einfach alle Knoten aufgenommen werden, was ebenfalls eine dominierende Menge wäre. Wären alle Knoten rot, so würden ebenfalls alle in $S$ (aufgrund der ersten Bedingung) aufgenommen werden.\\
Ansonsten werden Rote direkt aufgenommen und deren Nachbarn nicht. Also nur wenn ein Knoten keine roten Nachbarn hat. So ist die dominierende Menge nicht gleich der gesamten Menge an Knoten.

\subsection*{(b)}
$\frac{n}{n-1}$ %TODO ??????????
Für den Fall, dass alle bis auf ein Knoten in der Menge sind?


\subsection*{(c)}
%TODO ??????? Stimmt glaub nicht aber hab nichts besseres
$E(|S|) = f(p')$ mit $p' = P(v \in S)$

\subsection*{(d)}
Bei einem Kreis der mit Knotenanzahl $n$ mit $n\;mod\;3=0$ ist die Mächtigkeit der minimalen domininierenden Menge immer $\frac{n}{3}$.



\subsection*{(e)}
Hierbei handelt es sich jeweils um den Erwartungswert im Best-Case. Im durchschnittlichen Fall müsste man noch die Wahrscheinlichkeit für alle anderen Reihenfolgen von Nodes addieren.\\
%TODO DIES IST NUR DER ERWARTUNGSWERT FUER DEN BEST CASE!!!!!!!!!!!!!!!
$E(|S|)  = \sum_{i=0}^{n} 1 \cdot \frac{1}{3}$ %$+ Wahrscheinlichkeit$
 für $p = \frac{1}{3}$ und:\\
\\
$E(|S|)  = \sum_{i=0}^{n} 1 \cdot \frac{1}{2}$ für $p = \frac{1}{2}$.


\subsection*{(f)}
Für die Wahrscheinlichkeit $p_1 = \frac{1}{3}$ ist die Approximationsgüte höher also für die Wahrscheinlichkiet $p_2 = \frac{1}{2}$, da es für einen kreisförmigen Graphen optimal ist, wenn genau jeder dritte Punkt rot gefärbt wird. In diesem Fall werden dann nur rote Punkte zu $S$ hinzugefügt werden, und dazwischen immer zwei (zu roten benachbarten) blaue Punkte liegen, die nicht hinzugefügt werden müssen.\\
Dies würde genau einer minimalen dominierenden Menge entsprechen.\\
Mit der Wahrscheinlichkeit $p_2$ werden als Erwartungswert die Hälfte aller Punkte zu $S$ hinzugefügt. Selbst im besten Fall, wenn Knoten immer abwechselnd rot und blau gefärbt sind ist dies keine minimale dominierende Menge.\\
Im schlimmsten Fall jedoch, ist die Güte mit beiden Wahrscheinlichkeiten gleich, da der schlimmste Fall ist, wenn alle Elemente rot bzw. blau sind.









\section*{Aufgabe 2}
\subsection*{(a)} %TODO stimmt vllt nicht so ganz kekekekekek
Wir wählen zufällig einen Punkt aus. Von diesem Punkt aus konstruieren wir zwei Linien, die nach oben und nach rechts verlaufen. In dem Bereich, der von diesen Linien begrenzt wird, gehen wir nun rekursiv vor und wiederholen die beiden Schritte.\\
Dies tun wir so lange, bis in dem entstehenden Bereich keine Punkte mehr vorhanden sind. Der Punkt von dem aus wir dann die Linien gezeichnet haben ist nun der dominierende Punkt.


\subsection*{(b)}
%TODO laufzeit richtig analysieren... sollte n * log n sein eigentlich
Die Menge an Punkten, die der Algorithmus im jeden Rekursionsschritt betrachten muss wird immer kleiner. Um wie viel kleiner die Menge wird, hägt dabei vom zufällig gewählten Punkt aus.\\
Die Komplexität des Algoritmus ist $\Theta (n \cdot log \; n)$









\section*{Aufgabe 3}

\subsection*{(a)}
Da die kovexe Hülle alle Punkte beinhaltet muss für jede Kante, die zwei Punkte verbindet und Element der konvexen Hülle ist gelten, dass alle anderen Punkte auf einer bestimmten Seite dieser Kante sind.\\
Eine Möglichkeit für einen Algorithmus wäre also jede Mögliche Verbindung zwischen zwei Punkten auf genau diese Eigenschaft zu testen. Dazu wäre aber geschachtelte For-Loops nötig was eher ineffizient wäre.\\
Eine weitere Möglichkeit wäre folgende:\\
\begin{itemize}
	\item Suche nach den Punkten mit geringster x-Koordinate und höchster x-Koordinate.
	\item Verbinde diese beiden Punkte und teile so die gesamte Menge in zwei Hälften.
	\item Finde den Punkt mit der geringsten Distanz zu dieser Linie. Dieser Punkt verbunden mit den Endpunkten der Linie bildet nun ein Dreieck. Alle Elemente die dieses Dreieck umschließt können nicht Teil der konvexen Hülle sein und können somit "disqualifiziert" werden.
	\item im nächsten Schritt wird rekursiv vorgegangen indem man die bisherigen Schritte (ohne 1.) auf die Mengen anwendet, die durch die Linien des Dreiecks entstehen (ohne ursprüngliche Linie), anwendet.
	\item Dies geschieht so lange, bis keine Punkte mehr übrig sind. Die konvexe Hülle wird dann durch die Punkte gebildet, die nicht "disqualifiziert" wurden.
\end{itemize}


\subsection*{(b)}
\begin{lstlisting}
	function convex_hull_recursive(points):
		
		if points = Null:
			return remaining_points
			
		x_min = get_min_x(points)
		x_max = get_max_x(points)
		
		line = create_line(x_min, x_max)
		
		closest_to_line = points[0]
		for point in points:
			if get_dist(point, line) < get_dist(closest_to_line):
				closest_to_line = point
		discard_area = create_triangle(x_min, x_max, closest_to_line)
		
		remaining_points.append(get_points(points without points in discard_area))
		
		points.remove(points in discard_area)
		
		return convex_hull(points_above_line)
		return convex_hull(points_below_line)
\end{lstlisting}


\subsection*{(c)}
Bei dem Algorithmus handelt es sich um ein divide and conquer Verfahren. Die Laufzeit für einen einzelnen Schritt wird also mit jedem Durchlauf geringer, da zum einen die Menge halbiert wird, und zum anderen Punkte ignoriert werden.\\
Im schlechtesten Fall allerdings, also wenn keine Punkte eliminiert werden ist die Laufzeit in $\mathcal{O}(n^2)$, da in jedem Rekursionsschritt in eine Teilmenge die alle Punkte enthält und eine leere geteilt wird.
Es wird also in jedem Schritt lediglich ein Punkt abgearbeitet, woraus $n$ Rekursionsschritte resultieren. Aufgrund der Tatsache, dass in jedem Schritt alle Punkte betrachtet werden müssen, ergibt sich $\mathcal{O}(n^2)$.\\
Für die durchscnittliche Laufzeit nutzen wir die Rekursionsgleichung $T(n) = T(a \cdot n) + T(b \cdot n) + c \cdot n$, wobei $a$ und $b$ im Durschnitt gleich $\frac{1}{2}$ sind. $c \cdot n$ beschreibt die Suche nach dem jeweiligen "Pivot" Element. \\
Wendet man nun das Master Theorem auf die somit entstehende  Rekursionsgleichung $T(n) = 2T(\frac{1}{2}) + T(b \cdot n) + c \cdot n$ an, ergibt sich eine Laufzeit von $\mathcal{O}(n \cdot log\;n)$ für den Fall $c = log_b\;a$, da $a = 2, b=2, c = 1, d = 0$.





\section*{Aufgabe 4}
\subsection*{(a)}
$
B = 11,\\
S = \lbrace 2 \rbrace,\\
S' = \lbrace 2,8\rbrace,\\
A = \lbrace 2,4,8 \rbrace
$

\subsection*{(b)}
Unser Alogrithmus berechnet die subset-sum rekursiv für zufällige Teilmengen aus. Es handelt sich also um einen Divide and Conquer Algorithmus. Die Abbruchbedingung für die Rekursion ist, dass die Menge $A$ entweder aus einem oder keinem Element mehr besteht.\\
Solange dies jedoch noch nicht der Fall ist, wird die Menge $A$ an einem zufällig gewählten Index geteilt.\\
Anschließend wird der Algorithmus auf die beiden entstanden Teilmengen ausgeführt.\\
Die Lösung wird dann zusammengesetzt aus den jeweiligen ersten und zweiten Elementen der Teillösungen. Ist das zweite Element dieser Lösung kleiner als $B$, so wird diese ausgegeben. Falls nicht, lediglich der "rechte" Teil der Lösung ausgegeben. Auf diese Weise wird selbstverständlich nicht immer die korrekte Lösung ausgegeben. Es handelt sich also nur um eine Approximation.

\begin{lstlisting}
function subset-sum(A, B):
	if A.length == 1:
		return (A,A[0])
	if A.length == 0:
		return (null,0)


	random = get-random-integer(1, A.length))

	left = A[:rand]
	right = A[rand:]

	# calculate subsets recursively
	sol-left = subset_sum(left,B)
	sol-right = subset_sum(right,B)

	result = (sol-left[0] + sol-right[0], sol-left[1] + sol-right[1])

	if result[1] < B :	
		return result

	if sol-left[1] < sol-right[1]:
		return sol-right

	return sol-left
\end{lstlisting}

Da es sich bei dem Algorithmus um einen Divide and Conquer Algorithmus handelt, wird die Menge, die in jedem Rekursionsschritt betrachtet wird im Durchschnitt um die Hälfte kleiner.\\
Im Prinzip wird hier gleich vorgegangen wie beim bereits bekannten Quicksort Algorithmus, daher können wir uns an dessen Laufzeit orientieren.\\
Aus unserer Rekursionsgleichung 
$
2T\cdot \frac{n}{2} + \theta (n)$ mit $a=2, b=2$ und $\theta(n^{log_2\;2}) = \theta (n)$ resultiert nach dem Master Theorem eine Komplexität von $\Theta (n \cdot log\;n)$


\end{document}